import { Command } from "commander";
import fs from "node:fs";
import path from "node:path";
import { logger } from "../utils/helpers.js";

/**
 * List available data provider types
 */
function listProviderTypes() {
  const providerTypes = [
    {
      name: "rest",
      description: "RESTful API data provider",
      configOptions: ["apiUrl", "headers", "fetchOptions"]
    },
    {
      name: "graphql",
      description: "GraphQL API data provider",
      configOptions: ["apiUrl", "introspection", "headers"]
    },
    {
      name: "firebase",
      description: "Firebase/Firestore data provider",
      configOptions: ["projectId", "collection", "config"]
    },
    {
      name: "json-server",
      description: "JSON Server data provider",
      configOptions: ["apiUrl", "idAttribute"]
    },
    {
      name: "local-storage",
      description: "Browser LocalStorage data provider",
      configOptions: ["prefix", "storageKey"]
    },
    {
      name: "memory",
      description: "In-memory data provider",
      configOptions: ["data", "idAttribute"]
    }
  ];
  
  logger.title("Available Data Provider Types");
  
  for (const provider of providerTypes) {
    logger.info(`- ${provider.name}: ${provider.description}`);
    logger.info(`  Options: ${provider.configOptions.join(", ")}`);
  }
}

/**
 * Create a data provider configuration file
 */
function createProviderConfig(name, type, options) {
  const configDir = path.join(process.cwd(), "config", "data-providers");
  fs.mkdirSync(configDir, { recursive: true });
  
  const configPath = path.join(configDir, `${name}.js`);
  
  // Check if config already exists
  if (fs.existsSync(configPath)) {
    logger.warning(`Data provider config '${name}' already exists at ${configPath}`);
    return false;
  }
  
  // Parse options
  const parsedOptions = {};
  if (options) {
    for (const option of options.split(",")) {
      const [key, value] = option.split("=");
      if (key && value) {
        // Try to parse as JSON if possible
        try {
          parsedOptions[key.trim()] = JSON.parse(value.trim());
        } catch (e) {
          // If not valid JSON, use as string
          parsedOptions[key.trim()] = value.trim();
        }
      }
    }
  }
  
  // Create config file
  const configContent = `/**
 * ${name} Data Provider Configuration
 * Type: ${type}
 */
import { createDataProvider } from '@repo/data-base';

export const ${name}Provider = createDataProvider('${type}', ${JSON.stringify(parsedOptions, null, 2)});

// Export default provider
export default ${name}Provider;
`;

  fs.writeFileSync(configPath, configContent);
  logger.success(`Created data provider config '${name}' at ${configPath}`);
  return true;
}

/**
 * Create a data provider registry file
 */
function createProviderRegistry() {
  const configDir = path.join(process.cwd(), "config", "data-providers");
  fs.mkdirSync(configDir, { recursive: true });
  
  const registryPath = path.join(configDir, "index.js");
  
  // Get all provider files
  const providerFiles = fs.readdirSync(configDir)
    .filter(file => file.endsWith('.js') && file !== 'index.js');
  
  // Create registry content
  let registryContent = `/**
 * Data Provider Registry
 * Auto-generated by Zopio CLI
 */
import { providerRegistry } from '@repo/data-base';

// Import all providers
`;

  // Add imports
  for (const file of providerFiles) {
    const providerName = path.basename(file, '.js');
    registryContent += `import ${providerName}Provider from './${providerName}.js';\n`;
  }
  
  registryContent += `
// Register all providers
`;

  // Add registrations
  for (const file of providerFiles) {
    const providerName = path.basename(file, '.js');
    registryContent += `providerRegistry.register('${providerName}', ${providerName}Provider);\n`;
  }
  
  registryContent += `
// Export registry
export { providerRegistry };
`;

  fs.writeFileSync(registryPath, registryContent);
  logger.success(`Updated data provider registry at ${registryPath}`);
  return true;
}

/**
 * List all configured data providers
 */
function listProviders() {
  const configDir = path.join(process.cwd(), "config", "data-providers");
  
  if (!fs.existsSync(configDir)) {
    logger.info("No data providers configured yet.");
    return [];
  }
  
  const providerFiles = fs.readdirSync(configDir)
    .filter(file => file.endsWith('.js') && file !== 'index.js');
  
  if (providerFiles.length === 0) {
    logger.info("No data providers configured yet.");
    return [];
  }
  
  logger.title("Configured Data Providers");
  
  const providers = [];
  for (const file of providerFiles) {
    const providerName = path.basename(file, '.js');
    const providerPath = path.join(configDir, file);
    const content = fs.readFileSync(providerPath, 'utf8');
    
    // Extract type using regex
    const typeMatch = content.match(/createDataProvider\('([^']+)'/);
    const type = typeMatch ? typeMatch[1] : 'unknown';
    
    logger.info(`- ${providerName} (${type})`);
    providers.push({ name: providerName, type, path: providerPath });
  }
  
  return providers;
}

/**
 * Generate a CRUD resource using a specific data provider
 */
function generateResourceWithProvider(resource, provider, options) {
  // Get provider details
  const configDir = path.join(process.cwd(), "config", "data-providers");
  const providerPath = path.join(configDir, `${provider}.js`);
  
  if (!fs.existsSync(providerPath)) {
    logger.error(`Data provider '${provider}' not found.`);
    return false;
  }
  
  // Create resource directory
  const resourcesDir = path.join(process.cwd(), options.path || "resources");
  const resourceDir = path.join(resourcesDir, `${resource}s`);
  fs.mkdirSync(resourceDir, { recursive: true });
  
  // Create model file
  const modelPath = path.join(resourceDir, "model.js");
  const ResourceName = resource.charAt(0).toUpperCase() + resource.slice(1);
  
  const modelContent = `/**
 * ${ResourceName} Model
 */
export const ${ResourceName}Model = {
  name: '${ResourceName}',
  fields: {
    id: { type: 'string' },
    name: { type: 'string' },
    description: { type: 'string' },
    createdAt: { type: 'date' },
    updatedAt: { type: 'date' }
  },
  primaryKey: 'id',
  timestamps: true
};
`;

  fs.writeFileSync(modelPath, modelContent);
  
  // Create engine file with provider
  const enginePath = path.join(resourceDir, "engine.js");
  
  const engineContent = `/**
 * ${ResourceName} CRUD Engine
 * Using ${provider} data provider
 */
import { createCrudEngine } from '@repo/crud';
import { ${ResourceName}Model } from './model.js';
import { ${provider}Provider } from '../../config/data-providers/${provider}.js';

// Configure provider for this resource
const ${resource}Provider = ${provider}Provider.forResource('${resource}s', ${ResourceName}Model);

// Create CRUD engine
export const ${resource}Engine = createCrudEngine({
  dataProvider: ${resource}Provider,
  enableAudit: true,
  enablePermissions: true
});

// Export CRUD operations
export const get${ResourceName}s = (params) => ${resource}Engine.getList(params);
export const get${ResourceName} = (id) => ${resource}Engine.getOne({ id });
export const create${ResourceName} = (data) => ${resource}Engine.create({ data });
export const update${ResourceName} = (id, data) => ${resource}Engine.update({ id, data });
export const delete${ResourceName} = (id) => ${resource}Engine.delete({ id });
`;

  fs.writeFileSync(enginePath, engineContent);
  logger.success(`Created ${ResourceName} resource using ${provider} provider at ${resourceDir}`);
  return true;
}

export const dataProviderCommand = new Command("data-provider")
  .description("Manage data providers for CRUD operations")
  .option("-l, --list", "List all configured data providers")
  .option("-t, --types", "List available data provider types")
  .option("-a, --add <name>", "Add a new data provider configuration")
  .option("-p, --provider <type>", "Provider type (rest, graphql, firebase, etc.)")
  .option("-o, --options <options>", "Provider options as comma-separated key=value pairs")
  .option("-u, --update-registry", "Update the provider registry")
  .option("-g, --generate <resource>", "Generate a CRUD resource using a specific provider")
  .option("--provider-name <name>", "Provider name to use with generate")
  .option("--path <path>", "Path for generated resources", "resources")
  .action((options) => {
    if (options.types) {
      // List available provider types
      listProviderTypes();
    } else if (options.list) {
      // List configured providers
      listProviders();
    } else if (options.add && options.provider) {
      // Add a new provider configuration
      if (createProviderConfig(options.add, options.provider, options.options)) {
        // Update registry if requested or if it doesn't exist
        const registryPath = path.join(process.cwd(), "config", "data-providers", "index.js");
        if (options.updateRegistry || !fs.existsSync(registryPath)) {
          createProviderRegistry();
        } else {
          logger.info("Provider registry not updated. Use --update-registry to update it.");
        }
      }
    } else if (options.updateRegistry) {
      // Update provider registry
      createProviderRegistry();
    } else if (options.generate && options.providerName) {
      // Generate resource with provider
      generateResourceWithProvider(options.generate, options.providerName, {
        path: options.path
      });
    } else {
      // Show help if no valid options
      this.help();
    }
  });
